[{"content":"I\u0026rsquo;ve been convinced for a while now that Fedora is the cleanest, most \u0026ldquo;put together\u0026rdquo; of the mainstream Linux distros. With the release of Fedora 33, I was finally persuaded to make the move from Arch Linux to Fedora on my main workstation, in no small part because I really wanted to see what the Fedora team was doing with BTRFS. Call me disappointed when I found out that all they had really done with BTRFS was set it as default and roll a somewhat uninspired subvolume layout, but we\u0026rsquo;ll try to wrap our head around what we can do with the default setup. Here\u0026rsquo;s how the subvolumes look by default on Fedora:\n~ $ sudo btrfs sub list / ID 256 gen 43073 top level 5 path home ID 257 gen 43073 top level 5 path root ID 265 gen 31079 top level 257 path var/lib/machines  Looking at fstab I can see that the first two subvolumes are set up exactly where I\u0026rsquo;d expect them to be:\n~ $ cat /etc/fstab UUID=765f6fff-7a69-4af8-97e8-9e0171283a69\t/\tbtrfs\tsubvol=root\t0 0 UUID=44f6a310-41aa-4d2e-8a75-d1f02d92949b\t/boot\text4 defaults\t1 2 UUID=9FFB-450F\t/boot/efi\tvfat umask=0077,shortname=winnt\t0 2 UUID=765f6fff-7a69-4af8-97e8-9e0171283a69\t/home\tbtrfs subvol=home\t0 0  There wasn\u0026rsquo;t really much documentation to go off on how they intended me to start using BTRFS for its advanced features, besides two posts in the Fedora magazine, which, while posing a serviceable solution, didn\u0026rsquo;t really make the fullest use of the feature set of BTRFS.\nIn the end, I decided to go off my previous experience with BTRFS and use the snapper tool from SUSE. So, from this point forward, we\u0026rsquo;ll be looking at how we can use snapper to take automated incremental snapshots and restore from those on a live system instantly.\nManual Snapshotting First, we want to install snapper. Easy.\nsudo dnf install snapper  Our first step out of the box will be to set up a \u0026ldquo;config\u0026rdquo; which really acts like a repository for snapshots. I will be setting up snapshotting for the root subvolume, as that\u0026rsquo;s the area where I might need to revert changes (say, due to a borked update or major version upgrade - snapshotting root won\u0026rsquo;t include the kernel, more on that later).\nsudo snapper -c root create-config /  This will set up a config called root for the root directory. Note that because /home and var/lib/machines exist in separate subvolumes, they will be excluded from the snapshots. Handy! Now we know we can move our files into new subvolumes within our existing subvolumes to exclude those files from snapshots taken from the root of the \u0026ldquo;parent\u0026rdquo; subvolume.\nBut, moving on, let\u0026rsquo;s test out our new config to make sure everything works. I\u0026rsquo;ll take a snapshot called \u0026ldquo;base\u0026rdquo; to get us started:\nsudo snapper -c root create -d \u0026quot;base\u0026quot;  Now let\u0026rsquo;s confirm it\u0026rsquo;s creation:\n~ $ sudo snapper -c root list # | Type | Pre # | Date | User | Used Space | Cleanup | Description | Userdata ----+--------+-------+---------------------------------+------+------------+----------+-------------+--------- 0 | single | | | root | | | current | 1 | single | | Sat 07 Nov 2020 12:14:50 AM CET | root | 468.00 KiB | | base |  There she blows! We can see that the first snapshot was successfully created. A short note - if snapper list takes a long time for you, that has been my experience with it as well, so don\u0026rsquo;t be alarmed. Maybe we can fix this later.\nNow let\u0026rsquo;s test a rollback to make sure everything works. Create a file in your root directory, in my case a directory called /beacon and take another snapshot:\nsudo mkdir /beacon sudo snapper -c root create -d \u0026quot;beacon\u0026quot;  Check if the snapshot is there:\n~ $ sudo snapper -c root list # | Type | Pre # | Date | User | Used Space | Cleanup | Description | Userdata ----+--------+-------+---------------------------------+------+------------+----------+-------------+--------- 0 | single | | | root | | | current | 1 | single | | Sat 07 Nov 2020 12:14:50 AM CET | root | 468.00 KiB | | base | 2 | single | | Sat 07 Nov 2020 12:16:22 AM CET | root | 5.09 MiB | | beacon |  Nice! Now we can use snapper to get a list of what changed between the snapshots by referencing the id in the # column\u0026hellip; really handy for finding out why you borked your system (with a little create use of grep)\n~ $ sudo snapper -c root status 1..2 +..... /beacon c..... /var/lib/NetworkManager/timestamps c..... /var/log/audit/audit.log c..... /var/log/journal/1bdc1ee18ec74e4394197459cf787353/system.journal c..... /var/log/journal/1bdc1ee18ec74e4394197459cf787353/user-1000.journal c..... /var/log/snapper.log  We can see that /beacon was added, and there were some changes in my system logs, which is to be expected, naturally! Lets try a rollback\u0026hellip;\nsudo snapper -c root undochange 1..2  You should see that the root folder was reset to the state in the base snapshot, and the /beacon folder is now gone! You can roll back really complex changes in realtime while the filesystem is active, no problemo!\nAutomating Snapshotting Now that we know the basic commands to manage snapshots, let\u0026rsquo;s set up an automated timeline snapshot. This is enabled by default in the config\u0026rsquo;s configuration file, which will be located at /etc/snapper/configs/root. All we really need to do is turn on the associated systemd timer and set a snapshot retention policy that\u0026rsquo;s sympathetic to us. I have some space to spare and I\u0026rsquo;d like to have the freedom to make some bigger rollbacks (in case it takes me a while to realize there\u0026rsquo;s an issue I need to rollback for), so I told snapper to retain 72 snapshots. We\u0026rsquo;ll see over time if that\u0026rsquo;s using too much space, but I find it unlikely, considering all the snapshots I\u0026rsquo;ve seen so far are under 50MB and usually under 10MB. Here\u0026rsquo;s the relevant section in /etc/snapper/configs/root:\n# cleanup hourly snapshots after some time TIMELINE_CLEANUP=\u0026quot;yes\u0026quot; # limits for timeline cleanup TIMELINE_MIN_AGE=\u0026quot;1800\u0026quot; TIMELINE_LIMIT_HOURLY=\u0026quot;72\u0026quot; TIMELINE_LIMIT_DAILY=\u0026quot;10\u0026quot; TIMELINE_LIMIT_WEEKLY=\u0026quot;0\u0026quot; TIMELINE_LIMIT_MONTHLY=\u0026quot;10\u0026quot; TIMELINE_LIMIT_YEARLY=\u0026quot;10\u0026quot;  All that\u0026rsquo;s left at this point is to activate the systemd timer:\nsudo systemctl enable snapper-timeline.timer sudo systemctl start snapper-timeline.timer  Check that the timer is active:\n~ $ sudo systemctl status snapper-timeline.service ● snapper-timeline.service - Timeline of Snapper Snapshots Loaded: loaded (/usr/lib/systemd/system/snapper-timeline.service; static) Active: inactive (dead) since Sun 2020-11-08 20:00:02 CET; 40min ago TriggeredBy: ● snapper-timeline.timer Docs: man:snapper(8) man:snapper-configs(5) Process: 215148 ExecStart=/usr/libexec/snapper/systemd-helper --timeline (code=exited, status=0/SUCCESS) Main PID: 215148 (code=exited, status=0/SUCCESS) CPU: 6ms Nov 08 20:00:01 onyx systemd[1]: Started Timeline of Snapper Snapshots. Nov 08 20:00:01 onyx systemd-helper[215148]: running timeline for 'root'. Nov 08 20:00:02 onyx systemd[1]: snapper-timeline.service: Succeeded.  If we wait a couple hours, we should see that our snapper -c root list table is filling up with timeline snapshots!\n~ $ sudo snapper -c root list # | Type | Pre # | Date | User | Used Space | Cleanup | Description | Userdata ----+--------+-------+---------------------------------+------+------------+----------+-------------+--------- 0 | single | | | root | | | current | 1 | single | | Sat 07 Nov 2020 12:14:50 AM CET | root | 468.00 KiB | | base | 2 | single | | Sat 07 Nov 2020 12:16:22 AM CET | root | 5.09 MiB | | beacon | 3 | single | | Sat 07 Nov 2020 12:22:02 AM CET | root | 30.85 MiB | | rm geary | 4 | single | | Sat 07 Nov 2020 01:00:23 PM CET | root | 7.29 MiB | timeline | timeline | 5 | single | | Sat 07 Nov 2020 02:00:23 PM CET | root | 972.00 KiB | timeline | timeline | 6 | single | | Sat 07 Nov 2020 03:00:23 PM CET | root | 8.73 MiB | timeline | timeline | 7 | single | | Sat 07 Nov 2020 04:00:23 PM CET | root | 7.51 MiB | timeline | timeline | 8 | single | | Sat 07 Nov 2020 05:00:23 PM CET | root | 8.40 MiB | timeline | timeline | 9 | single | | Sat 07 Nov 2020 06:00:23 PM CET | root | 83.77 MiB | timeline | timeline | 10 | single | | Sat 07 Nov 2020 07:00:23 PM CET | root | 1.59 MiB | timeline | timeline | 11 | single | | Sat 07 Nov 2020 08:00:23 PM CET | root | 956.00 KiB | timeline | timeline | 12 | single | | Sat 07 Nov 2020 09:00:23 PM CET | root | 7.96 MiB | timeline | timeline | 13 | single | | Sat 07 Nov 2020 10:00:23 PM CET | root | 516.00 KiB | timeline | timeline |  And that\u0026rsquo;s it!\nI mentioned before that we don\u0026rsquo;t capture the kernel in these snapshots. So for the best results, if you roll back to a period with a previous kernel, it\u0026rsquo;s probably best (for consistency reasons, if nothing else), to roll back the kernel by booting the previous kernel in GRUB before you roll back the system.\nHappy snapshotting!\n","date":"2020-11-08","permalink":"https://ahvth.github.io/post/f33-btrfs-guide/","tags":["guide","brfs","backup","snapshotting"],"title":"Getting Started with BTRFS Snapshotting"},{"content":" This is an iteration on an article I previously posted to medium.com\n There are a lot of resources out there on installing Arch Linux, but when I first started with the subject, I always found it difficult to find that one guide with all of the commands spelled out for me with useful examples. So, haphazardly sprawling out on the page below me shall be a list of commands to create a conservative system layout in mostly chronological order. This should serve as a reference for new Arch users going through their first installations, or for experienced users who just need a quick checklist with some handy optimizations over the official guide.\nRead the official installation guide\nGet Arch\nChapter 1: The LiveUSB Installer version used at the time of this article’s creation: ARCH_202003\nThe first steps of any Arch installation happen on the Arch LiveUSB\nKeyboard Querying available keyboard layouts find /usr/share/kbd/keymaps/ -type f | more  Configuring the keyboard loadkeys hu  UEFI / BIOS Querying BIOS or UEFI\nls /sys/firmware/efi/efivars  OR\nefivar -l   If the queries above do not return anything, then the system is running in BIOS (Legacy) mode. If a list is returned, the available UEFI functions will be listed\n Internet Verifying the internet connection ping -c 4 archlinux.org ifconfig  Time and Date Setting time and date timedatectl set-ntp true  Disks Querying disks fdisk -l  Disk table creation or modification Find your block device ID:\nlsblk   Note: block devices aren\u0026rsquo;t all labeled /dev/sda as in the examples below (these are SATA devices). Other block device naming schemes exist such as nvme0pX, where the last character is the partition number.\n parted /dev/sda mklabel MSDOS # or mklabel gpt  Partitioning cfdisk /dev/sda  // This will open the cfdisk ncurses disk utility\n// Example system configuration:\n Do not copy unless you know the settings are correct for your desired layout.\n --\u0026gt; [ dos ] // If no option is presented, clear the current partition table with: wipefs -a /dev/sda OR parted\n--\u0026gt; [ new ] // Create an EFI parition, if working in EFI mode (Type: EFI F32)\n--\u0026gt; [ new ] // Create a system partition (Type: Linux ext4)\n--\u0026gt; [ bootable ] // BOOT-flag (for BIOS / Legacy systems)\n--\u0026gt; [ new ] // Create a /home partition (Type: Linux ext4)\n--\u0026gt; [ new ] // Create a swap partition if desired (Type: Linux swap)\n--\u0026gt; [ write ] // Write changes to disk\n--\u0026gt; [ quit ] // Exit\nCreate or format a filesystem  /dev/sdaX represents the partition number of the corresponding partition you just created, such as /dev/sda1\n // Default filesystem for EFI partitions is FAT32\nmkfs.vfat /dev/sdaX  System partition\n// Default filesystem for the system partition is ext4\nmkfs.ext4 /dev/sdaX  Swap partition\n// Formatting the swap partition\nmkswap /dev/sdaX  // Activating the swap partition\nswapon /dev/sdaX  Mounting partitions // The system partition is where the root filesystem will be located\nmount /dev/sdaX /mnt  // If you have chosen to use a separate partition for your home folder, then create a mount point for that partition\nmkdir /mnt/home  // The home partition will be where the /home folder is located\nmount /dev/sdaX /mnt/home  Mirrors and base system install Configuring pacman mirrorlist vim /etc/pacman.d/mirrorlist  // The best strategy is to place the closest server to you by geo-location to the top of the list\nReflector Alternatively, the reflector tool can be used to automatically sort mirrors according to various sorting methods.\n// reflector must be installed separately as it is not included in the LiveUSB image\npacman -S reflector  // The following example command will select the fastest mirror in a given country (using Hungary as an example)\nreflector --country Hungary --protocol https --sort rate --save /etc/pacman.d/mirrorlist  Usage information here.\nInstalling the base system pacstrap /mnt base base-devel linux linux-firmware   To solve hardware compatibility or stability issues resulting from the mainline kernel, use the linux-lts package\n Chapter 2 - The chroot Environment Prepare to change from the LiveUSB to the destination filesystem.\n// Generate the fstab for the destination filesystem\ngenfstab -U /mnt \u0026gt;\u0026gt; /mnt/etc/fstab  // Change over to the destination filesystem\narch-chroot /mnt  Locale and Hostname Timezone ln -sf /usr/share/zoneinfo/Europe/Budapest /etc/localtime  System time hwclock --systohc  Character encoding vim /etc/locale.gen  // Uncomment your desired locale\u0026rsquo;s encoding option\nlocale-gen  // Optionally, depending on desired desktop environment (add with your desired locale to /etc/locale.conf)\nLANG=hu_HU.UTF-8 LC_ADDRESS=hu_HU.UTF-8 LC_COLLATE=hu_HU.UTF-8 LC_CTYPE=hu_HU.UTF-8 LC_IDENTIFICATION=hu_HU.UTF-8 LC_MEASUREMENT=hu_HU.UTF-8 LC_MESSAGES=hu_HU.UTF-8 LC_MONETARY=hu_HU.UTF-8 LC_NAME=hu_HU.UTF-8 LC_NUMERIC=hu_HU.UTF-8 LC_PAPER=hu_HU.UTF-8 LC_TELEPHONE=hu_HU.UTF-8 LC_TIME=hu_HU.UTF-8  Keyboard layout // Use your desired keyboard layout\necho \u0026quot;KEYMAP=hu \u0026gt; /etc/vconsole.conf\u0026quot;  Hostname // Use your desired hostname here\necho HOSTNAME \u0026gt; /etc/hostname  Users // Generate root user password\npasswd  // Add your user (-m modifier creates a home folder for the user)\nuseradd -mg wheel exampleuser  // Assign a password to user\npasswd exampleuser  // To enable use of sudo, uncomment the following line in /etc/sudoers\nvim /etc/sudoers  // Uncomment\n%wheel ALL=(ALL) ALL  Packages X.org pacman -S dialog xorg xorg-xinit xorg-xauth xterm  GRUB  Skip to the next section if using GRUB with UEFI\n  Again, replace /dev/sda with the target block device you used above.\n pacman -S grub grub-mkconfig -o /boot/grub/grub.cfg grub-install /dev/sda  GRUB + UEFI // UEFI boot requires both grub and efibootmgr\npacman -S grub efibootmgr  // If this command returns the error cannot find EFI directory, you didn\u0026rsquo;t create your EFI partition correctly.\n /dev/sdaX is the efi partition you created in Chapter 1\n mkdir /efi mount /dev/sdaX /efi  // Install GRUB\n You can use whatever value you like in as the bootloader-id. This will be the name of the UEFI entry created for Arch.\n grub-install --target=x86_64-efi --efi-directory=efi --bootloader-id=ARCH grub-mkconfig -o /boot/grub/grub.cfg  Graphical environments // Some examples:\npacman -S gnome pacman -S lightdm lxde-gtk3 pacman -S lightdm mate pacman -S lxdm i3-wm  Display manager initialization GNOME // If you are using GNOME\nsystemctl enable gdm  LXDE, MATE // If you are using LXDE or MATE\nsystemctl enable lightdm  i3 // A simple graphical login for i3wm is LXDM\nsystemctl enable lxdm  Initializing the network daemon  Some DE packages may not include a network manager, NetworkManager is recommended\n pacman -S networkmanager systemctl enable NetworkManager.service  Reboot The final step is to exit chroot reboot into your freshly installed Arch installation:\nexit reboot  Congratulations and enjoy your new Arch system!\n","date":"2020-11-07","permalink":"https://ahvth.github.io/post/arch-installation/","tags":["arch","guide"],"title":"Arch Linux Demystified a.k.a. an Arch Linux Install Reference"}]